Тъй като курсът се фокусира върху обектно-ориентираното програмиране и неговата реализация в езика C++, най-важното изискване за проектите е те да са изградени, съгласно добрите принципи на ООП. Решение, в което кодът е процедурен, има лоша ООП архитектура и т.н., се оценява с нула точки. 
Не се позволява използване на функционалност и библиотеки извън тези, декларирани в следните заглавни файлове <iostream>, <fstream>, <new>, <cstring>, <cmath>, <cstdlib>, <exception>, <stdexcept>, <chrono>, <ctime>, <string> и <vector>. Ако искате да използвате определена библиотека, която не е включена в списъка, обърнете се към титулярите на курса за разрешение.
Други важни критерии за оценка на проектите са:
Дали решението работи коректно, съгласно спецификацията. Решение, което не работи и/или не се компилира, носи минимален брой (или нула) точки.
Дали решението отговаря на заданието на проекта.
Дали е извършен анализ на поставената задача и на различните подходи за нейното решаване.
Каква част от необходимата функционалност е била реализирана.
Дали са обхванати всички потенциални сценарии за използване на функционалността.
Дали решението е изградено съгласно добрите практики на обектно-ориентирания стил. Тъй като курсът се фокусира върху ООП, решения, които не са обектно-ориентирани, се оценяват с нула или минимален брой точки.
Дали е постигната оптимална сложност на реализираните алгоритми (ако има такива и спрямо текущите ви познания).
Дали е постигнато оптимално управление на паметта, включително заделяне и освобождаване на динамична памет, статични член-данни, глобални променливи.
Оформление на решението. Проверява се дали кодът е добре оформен, дали е спазена конвенция за именуване на променливите, дали е добре коментиран и т.н.
Дали решението е било добре тествано. Проверява се какви тестове са били проведени върху приложението, за да се провери дали то работи коректно. Очаква се по време на защитата да можете да посочите как сте тествали приложението, за да проверите дали то работи коректно и как се държи в различни ситуации.
Дали коректно са прихванати и обработени възможните грешки от различен характер – грешен или некоректен вход от потребителя, проблеми с външни ресурси (памет, файлове) и др. При възникнали проблеми програмата трябва да реагира адекватно и да се стреми да запази максимално данните коректни и цели. Да не се допуска изтичане на памет и всякакви други ресурси. 
Добра комуникация с потребителите. Например при грешно поведение на потребителите, възникване на системна грешка или друга невъзможност да се извърши исканото действие, програмата ви трябва да се стреми да остане в работещо състояние, като уведоми подходящо потребителя. 
Качество и пълнота на представената документация.
Идеи и потенциал за бъдещи разширения. За ООП стила е важно кодът да е лесен за промяна и разширяване.
Представяне на проекта.
Възможност за бърза реализация на малка промяна в проекта (познаване на кода) и отговаряне на въпроси.
____________________________________________________________________________________________________________
Тема №10 Password manager
В рамките на този проект трябва да се реализира приложение, в което да се съхраняват вашите пароли. Като минимум, вашето приложение трябва да поддържа следните криптиращи алгоритми: шифърът на Цезар (Caesarcipher), Text code и Hill cipher.
Шифърът на Цезар
Всяка буква се отмества с предварително зададена стъпка надясно. Например,  ако стъпката за изместване е 3, то буквата A става D. Ако се намираме на края на азбуката и надминем общия брой символи, които са ни дадени, се връщаме в началото на азбуката. 
Повече информация: https://en.wikipedia.org/wiki/Caesar_cipher
Text code: 
Програмата получава текст, чието съдържание определя всички възможни букви,  които трябва да се ползват в паролите. Нека да покажем как работи кодирането със следния пример.
Да разгледаме текста:
“the brown fox jumps over the lazy dog THE BROWN FOX JUMPS OVER THE LAZY DOG”
‘  ’ - 3
A - 68
B - 42
.
.
.
y - 32
z - 31
A се кодира с 68, защото точно на 68-ма позиция виждаме първото срещане на A. Същото се отнася за B, C и т.н. Важен детайл е, че включваме и други допълнителни символи, като интервал, който се среща за първи път на позиция 3.
Всяка буква отговаря се кодира с позицията, на която се среща в текста.
След като потребителят зададе своята парола,тя се съхранява кодирана, като всяка буква се заменя с число по описания по-горе начин.
Нека покажем пример за кодиране със същия текст описан по горе.
Вход: TestVhod
Изход: {38, 2, 18, 0, 59, 1, 6, 34}
Шифър на Хил 
Кодирането се извършва по следния начин. На всяка буква се съпоставя число по модул 26. Буквите от латинската азбука се кодират с числа 0 до 25: A - 0, B - 1, …, Z - 25.
В този шифър трябва да допуснем, че имаме и ключ матрица а от пръстена M_{n, n}(Z_26), която е обратима. Тогава можем да представим нашата дума като вектор b с дължина n. Кодираната дума ще бъде b.a и ако искаме да я декодираме, можем да постигнем това, като умножим b.a.a^{-1}. 
Примери и допълнително обяснение: https://en.wikipedia.org/wiki/Hill_cipher

Вашите имплементации на методите за кодиране трябва да работят над ASCII символите от 32 до 126. Единствено изключение прави шифърът Text code, който трябва да работи над множеството от символи, подадени му на входа.
Команден интерфейс
Създаване на файл за пазене на пароли
>> create <име на файл за пазене на паролите> <шифър> <password>
Потребителят трябва да добави необходимата за кодирането информация за всеки различен тип шифър. Например за шифъра на Цезар, трябва да се добави като параметър броят позиции, с които се отмества паролата. При Text code, трябва да се подаде локацията на текстов файл, в който се съдържа текста, необходим за кодирането, и т.н.
Самият файл трябва да бъде криптиран с избран от вас алгоритъм с парола (конфигурация) <password>.
Отваряне на файл със съхранени пароли
>> open <име на файл за пазене на пароли> <password>
Отваря файла, в който са съхранени паролите. Шифриращият алгоритъм и цялата конфигурацията за него трябва да се разбере от съдържанието на файла. Файлът се разкриптира според паролата <password>.
Добавяне на нова парола във файл
>> save <website> <user> <password>
Запазва в отворения файл парола за дадения сайт и потребител.
Зареждане на парола
>> load <website> [<user>]
Показва запазената парола за дадения сайт и потребител. Ако потребител не е подаден, изброява всички потребители с техните пароли.
Промяна на парола
>> update <website> <user> <new-password>
Променя парола за даден сайт и потребител. Ако такава все още не е запазена да сигнализира чрез подходящо съобщение. Също и ако новата парола съвпада със старата
Премахване на парола
>> delete <website> [<user>]
Премахва съхранена парола за даден сайт и потребител. Ако потребител не е посочен се премахват всички записи за този сайт.
Важно за вашето приложение е лесно добавяне на нови шифри и команди.
Навсякъде, където има нужда, трябва да се направи валидация на входните данни.
